<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Ansible in detail</title>
    <style type="text/css">
pre code {
  font-family: courier new;
  font-size: 9pt;
}
span.console-yellow {
  color: #FCE94F;
}
span.console-green {
  color: #8AE234;
}
span.console-blue {
  color: #3465A4;
}
span.console-red {
  color: #EF2929;
}
span.console-input {
  font-weight: bold;
  font-size: 10pt;
}
dd {
  margin-left: 2em;
  margin-bottom: 0.5em;
}
span.doc-link {
  font-size: smaller;
}
li ul {
  margin-bottom: 0;
}
table.module-option {
  border-collapse: collapse;
}
table.module-option th {
  font-weight: bold;
  text-align: center;
}
table.module-option th,
table.module-option td
{
  border: 1px solid gray;
  padding: 2px;
  font-size: 10pt;
  background-color: #f8f8f8;
  vertical-align: middle;
}
table.module-option td.comments {
  text-align: left;
}
    </style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721713-1', 'yteraoka.github.io');
  ga('send', 'pageview');

</script>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Ansible in detail</h1>
          <h2>あんしぼー 詳細</h2>
        </header>

        <hr>

        <section id="main_content">

<h3><a name="table-of-contents" class="anchor" href="#table-of-contents"><span class="octicon octicon-link"></span></a>目次</h3>

<p>
<ul>
  <li><a href="#inventory-file">インベントリファイル</a>
    <ul>
      <li><a href="#inventory-file-grouping">グルーピング</a></li>
      <li><a href="#inventory-file-hostvars">サーバー変数</a></li>
    </ul>
  </li>
  <li><a href="#ssh-config">SSHまわりの設定</a></li>
  <li><a href="#ansible-playbook">ansible-playbook コマンド</a></li>
  <li><a href="#modules">モジュール</a>
    <ul>
      <li><a href="#module-file">file</a> (ファイル・ディレクトリ操作)</li>
      <li><a href="#module-copy">copy</a> (ファイルを配る)</li>
      <li><a href="#module-fetch">fetch</a> (ファイルを収集する)</li>
      <li><a href="#module-lineinfile">lineinfile</a> (ファイルの行を編集)</li>
      <li><a href="#module-user">user</a> (ユーザーアカウントの管理)</li>
      <li><a href="#module-yum">yum</a> (yum でのパッケージ管理)</li>
      <li><a href="#module-command">command</a> (任意のコマンドを実行する)</li>
      <li><a href="#module-pause">pause</a> (一時停止)</li>
    </ul>
  </li>
  <li><a href="#register-variables">結果を変数に保存して利用する</a></li>
  <li><a href="#gathering-facts">サーバーの情報を利用する (GATHERING FACTS)</a></li>
  <li><a href="#conditional-execution">条件付き実行</a></li>
  <li><a href="#backup-file">Backup File</a></li>
  <li><a href="#module-ignore_errors">エラーを無視する</a></li>
  <li><a href="#advanced-playbook">Advanced Playbook</a></li>
<!--
  <li><a href="#"></a></li>
-->
</ul>
※こちらも鋭意作成中です。
</p>

<h3><a name="inventory-file" class="anchor" href="#inventory-file"><span class="octicon octicon-link"></span></a>インベントリファイル</h3>
<p>
Ansible では制御対象のサーバーのリストをインベントリファイルに書く必要があり、EPEL Repository から yum でインストールした場合、このファイルは <code>/etc/ansible/hosts</code> を使うように <code>/etc/ansible/ansible.cfg</code> で定義してある。が、<code>ansible</code>, <code>ansible-playbook</code> コマンドでは <code>-i</code> オプションで任意のファイルを指定することができる。Best Practices のドキュメントには test, staging, production などによってインベントリファイルを使い分けるよう書いてあります。<br>
<br>
コマンドラインオプションの他に <code>ANSIBLE_HOSTS</code> という環境変数で指定することもできます。
<pre><code>$ <span class="console-input">export ANSIBLE_HOSTS=/path/to/inventory-file</span></code></pre>

<h3><a name="inventory-file-grouping" class="anchor" href="#inventory-file-grouping"><span class="octicon octicon-link"></span></a>グルーピング</h3>
インベントリファイルには対象ホストのホスト名もしくはIPアドレスを列挙します。
グルーピングすることができ、playbook の <code>hosts</code> 設定で対象を特定のグループに絞ったりできます。<br>
<br>
グルーピングの例
<span class="doc-link">(<a href="http://www.ansibleworks.com/docs/patterns.html#id2">Hosts and Groups</a>)</span>
<pre><code>[app-servers]
app01
app02
app03

[db-servers]
db01
db02
db03
</code></pre>

連番のサーバー名であれば次の様に書くこともできます。
<pre><code>[webservers]
www[01:50].example.com

[databases]
db-[a:f].example.com
</code></pre>


<code>&</code> や <code>!</code> などで複雑な指定も可能です。
<span class="doc-link">(<a href="http://www.ansibleworks.com/docs/patterns.html#id4">Selecting Targets</a>)</span>

<br>
<br>

<h3><a name="inventory-file-hostvars" class="anchor" href="#inventory-file-hostvars"><span class="octicon octicon-link"></span></a>ホスト変数</h3>
インベントリファイルではホスト名、IPアドレスの後ろにそのサーバー用の変数を任意に複数指定できます。
<pre><code>server1  listen_port=80 relay_server=relay1
server2 listen_port=81 relay_server=relay2</pre></code>

予約変数名<br>
次の SSH の項目で説明しますが、SSH 関連で予約されている変数名があります。
<dl>
  <dt>ansible_ssh_host</dt>
  <dd>あまり必要な場面がなさそうですが、イベントリのホスト名とSSH接続用のホスト名を分けたい場合に指定</dd>
  <dt>ansible_ssh_port</dt>
  <dd>SSHポートが他と違う場合に指定する</dd>
  <dt>ansible_ssh_user</dt>
  <dd>SSHのユーザー名が他と違う場合に指定する</dd>
  <dt>ansible_ssh_pass</dt>
  <dd>SSHでパスワード認証する際のパスワードを指定</dd>
  <dt>ansible_connection</dt>
  <dd>対象サーバーへの接続方法 (local, ssh, paramiko)、デフォルトは paramiko</dd>
  <dt>ansible_ssh_private_key_file</dt>
  <dd>SSHの秘密鍵が他と違う場合に指定</dd>
  <dt>ansible_syslog_facility</dt>
  <dd>対象サーバーで出力する syslog の facility</dd>
  <dt>ansible_python_interpreter</dt>
  <dd>対象サーバーでの Python の path を指定する。/usr/bin/python 以外を使いたい場合などに使う。/usr/bin/python が古い場合とか</dd>
  <dt>ansible_*_interpreter</dt>
  <dd>対象サーバーでの ruby とか perl の path を指定</dd>
</dl>

</p>

<h3><a name="ssh-config" class="anchor" href="#ssh-config"><span class="octicon octicon-link"></span></a>SSHまわりの設定</h3>
<p>
Ansible はデフォルトでは SSH 接続に Python の paramiko を使う(RHEL 6 の OpenSSH は古くて ControlPersist 機能がないため?)、このためか ~/.ssh/config を読んではくれない。標準の path の秘密鍵以外を使いたい場合や 22 番以外のポートを使いたい場合はインベントリファイルにホスト毎、グループ毎、全体の変数を設定する。

Version 1.2.1 からは OpenSSH が <code>ControlPersist</code> をサポートしている場合は <code>ssh</code> で、そうでない場合は <code>paramiko</code> となる <code>smart</code> がデフォルトとなるようです。
<br>
<pre><code>[group-a]
server1 ansible_ssh_port=2222
server2 ansible_ssh_user=bob

[group-b]
server3
server4

[group-b:vars]
ansible_ssh_port=3333

[all:vars]
ansible_ssh_port=1234
</code></pre>
<br>
秘密鍵だけはコマンドラインオプションで指定できる
<pre><code>$ <span class="console-input">ansible --private-key=/path/to/key_file</span></code></pre>
変数の強度は「host &gt; group &gt; all &gt; コマンドラインオプション」の順。
</p>

<h3><a name="ansible-playbook" class="anchor" href="#ansible-playbook"><span class="octicon octicon-link"></span></a>ansible-playbook コマンド</h3>
<p>
オプション
<dl>
  <dt><code>-k, --ask-pass</code></dt>
  <dd>SSH のパスワードを尋ねる(プロンプトが出る)</dd>
  <dt><code>-K, --ask-sudo-pass</code></dt>
  <dd>sudo のパスワードを尋ねる(プロンプトが出る)</dd>
  <dt><code>-C, --check</code></dt>
  <dd>インストールなどの変更は行わないが、条件の確認などは実行する</dd>
  <dt><code>-c CONNECTION, --connection=CONNECTION</code></dt>
  <dd>local, ssh, paramiko から選択。デフォルトは paramiko。古い OpenSSH で ssh を指定する場合は <code>ANSIBLE_SSH_ARGS=""</code> と環境変数を空で上書きする必要がある</dd>
  <dt><code>-D, --diff</code></dt>
  <dd>file や template の差分(diff)を表示する。<code>--check</code> と一緒に使うと便利</dd>
  <dt><code>-e EXTRA_VARS, --extra-vars=EXTRA_VARS</code></dt>
  <dd>追加の変数を key=value で指定する。playbook に書かれている変数の上書きはされない</dd>
  <dt><code>-f FORKS, --forks=FORKS</code></dt>
  <dd>並列実行する数(デフォルトは5)</dd>
  <dt><code>-h, --help</code></dt>
  <dd>このヘルプメッセージを表示して終了する</dd>
  <dt><code>-i INVENTORY, --inventory-file=INVENTORY</code></dt>
  <dd>インベントリファイルを指定する(デフォルトは /etc/ansible/hosts)</dd>
  <dt><code>-l SUBNET, --limit=SUBNET</code></dt>
  <dd>対象サーバーを指定のものだけに制限する</dd>
  <dt><code>--list-hosts</code></dt>
  <dd>それぞれの playbook の対象ホスト一覧を表示して終了する。playbook の実行はされない</dd>
  <dt><code>--list-tasks</code></dt>
  <dd>各 playbook のタスク一覧を表示して終了する</dd>
  <dt><code>-M MODULE_PATH, --module-path=MODULE_PATH</code></dt>
  <dd>モジュールファイルのディレクトリを指定する(デフォルトは /usr/share/ansible)</dd>
  <dt><code>--private-key=PRIVATE_KEY_FILE</code></dt>
  <dd>SSH の秘密鍵ファイルを指定する</dd>
  <dt><code>--start-at-task=START_AT</code></dt>
  <dd>指定の task から開始する</dd>
  <dt><code>--step</code></dt>
  <dd>ひとつの task ごとに "Perform task: タスク名 (y/n/c):" と確認される。y: (yes) 実行する、n: (no) 実行しない、c: (continue) 以降を確認なしで実行する</dd>
  <dt><code>-s, --sudo</code></dt>
  <dd>対象サーバーでの task を sudo で実行する</dd>
  <dt><code>-U SUDO_USER, --sudo-user=SUDO_USER</code></dt>
  <dd>sudo での実行ユーザーを指定する(デフォルトは root)</dd>
  <dt><code>--syntax-check</code></dt>
  <dd>playbook の文法チェックだけを行う</dd>
  <dt><code>-t TAGS, --tags=TAGS</code></dt>
  <dd>指定の tag が付けられた task のみを実行する</dd>
  <dt><code>-T TIMEOUT, --timeout=TIMEOUT</code></dt>
  <dd>SSH のタイムアウトを指定する(デフォルトは10秒)</dd>
  <dt><code>-u REMOTE_USER, --user=REMOTE_USER</code></dt>
  <dd>SSH で接続するユーザー名を指定する</dd>
  <dt><code>-v, --verbose</code></dt>
  <dd>冗長モード (-vvv でより冗長な出力になる)</dd>
  <dt><code>--version</code></dt>
  <dd>バージョンを表示して終了する</dd>
</dl>
</p>


<h3><a name="modules" class="anchor" href="#modules"><span class="octicon octicon-link"></span></a>モジュール</h3>
<p>
Ansible の Playbook を書くにはどんな module があるのかを知り、用途にあったものを使うようにする必要があります。
</p>

<h3><a name="module-file" class="anchor" href="#module-file"><span class="octicon octicon-link"></span></a>file モジュール</h3>
<p>
ファイル、シンボリックリンク、ディレクトリの所有者やモードの設定、削除削除を行うモジュールです。
他の多くのモジュールが同じオプションをサポートしています copy, template, assemble など。

<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>force</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">yes にすると2つのケースでシンボリックリンクを強制的に作成します。1) リンク元ファイルが存在しない場合 2) リンク先にファイルが存在する場合(unlink 後にリンクを作成します)</td>
</tr>
<tr>
  <td>group</td>
  <td></td>
  <td></td>
  <td class="comments">グループ (chown で使うもの)</td>
</tr>
<tr>
  <td>mode</td>
  <td></td>
  <td></td>
  <td class="comments">モード (chmod で使うもの)</td>
</tr>
<tr>
  <td>owner</td>
  <td></td>
  <td></td>
  <td class="comments">ファイルの所有者 (chown で使うもの)</td>
</tr>
<tr>
  <td>path <span class="required">*</span></td>
  <td></td>
  <td></td>
  <td class="comments">ファイルやディレクトリのpath、<code>state=link</code> の場合は <code>src</code> に対するリンク先を指定します。</td>
</tr>
<tr>
  <td>recurse</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">state=directory の場合に attribute 設定を再帰的に行うかどうか</td>
</tr>
<tr>
  <td>selevel</td>
  <td>s0</td>
  <td></td>
  <td class="comments">level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the <code>range</code>. <code>_default</code> feature works as for seuser.</td>
</tr>
<tr>
  <td>serole</td>
  <td></td>
  <td></td>
  <td class="comments">role part of SELinux file context, <code>_default</code> feature works as for seuser.</td>
</tr>
<tr>
  <td>setype</td>
  <td></td>
  <td></td>
  <td class="comments">type part of SELinux file context, <code>_default</code> feature works as for seuser.</td>
</tr>
<tr>
  <td>seuser</td>
  <td></td>
  <td></td>
  <td class="comments">user part of SELinux file context. Will default to system policy, if applicable. If set to <code>_default</code>, it will use the <code>user</code> portion of the policy if available.</td>
</tr>
<tr>
  <td>src</td>
  <td></td>
  <td></td>
  <td class="comments">シンボリックリンクのリンク元path</td>
</tr>
<tr>
  <td>state</td>
  <td>file</td>
  <td>file<br>link<br>directory<br>hard<br>absent</td>
  <td class="comments"><code>directory</code> の場合、<code>mkdir -p</code> のように途中の directory も作成します。<code>absent</code> の場合、directory は再帰的に削除され、ファイルやリンクは unlink されます。</td>
</tr>
</table>
<span class="required">*</span> は必須<br>
<br>
例
<pre><code>- file: path=/etc/foo.conf owner=foo group=foo mode=0644
- file: src=/file/to/link/to dest=/path/to/symlink owner=foo group=foo state=link
</code></pre>
</p>

<h3><a name="module-copy" class="anchor" href="#module-copy"><span class="octicon octicon-link"></span></a>copy モジュール</h3>
<p>
Ansible 実行サーバーからリモートサーバーにファイルをコピーするモジュールです。<br>
このモジュールはディレクトリを再帰的にコピーすることができません。<br>
(rsync コマンドを使う例が <a href="http://www.ansibleworks.com/docs/playbooks2.html/#delegation">delegation</a> にあります)
<pre><code># Playbook からの例
- copy: src=/srv/myfiles/foo.conf dest=/etc/foo.conf owner=foo group=foo mode=0644

# ntp.conf をコピーします。既に存在するファイルと差分がある場合は元のファイルをバックアップします
- copy: src=/mine/ntp.conf dest=/etc/ntp.conf owner=root group=root mode=644 backup=yes

# sudoers ファイルを dest の path にコピーする前に visudo コマンドでバリデーションを実行します
- copy: src=/mine/sudoers dest=/etc/sudoers validate='visudo -cf %s'
</code></pre>
<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>backup</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">既存ファイルと内容に差があった場合にバックアップ日時をファイル名に含むバックアップファイルを作成します。</td>
</tr>
<tr>
  <td>content</td>
  <td></td>
  <td></td>
  <td class="comments"><code>src</code> の代わりに使用することで、ここに設定したデータがファイルの内容となります。</td>
</tr>
<tr>
  <td>dest <span class="required">*</span></td>
  <td></td>
  <td></td>
  <td class="comments">コピー先の path</td>
</tr>
<tr>
  <td>force</td>
  <td>yes</td>
  <td>yes<br>no</td>
  <td class="comments">デフォルトは yes で、ファイルの内容に差があればコピーします。no の場合はファイルが存在すると上書きしません</td>
</tr>
<tr>
  <td>src</td>
  <td></td>
  <td></td>
  <td class="comments">コピーするファイルのpath。絶対pathでも相対pathでも可</td>
</tr>
<tr>
  <td>validate</td>
  <td></td>
  <td></td>
  <td class="comments">コピーする前に validation するコマンドを指定</td>
</tr>
<tr>
  <td>その他</td>
  <td></td>
  <td></td>
  <td class="comments">file モジュールで指定可能なものすべてが使えます</td>
</tr>
</table>
<span class="required">*</span> は必須<br>
<br>
</p>

<h3><a name="module-fetch" class="anchor" href="#module-fetch"><span class="octicon octicon-link"></span></a>fetch モジュール</h3>
<p>
<a href="#module-copy">copy</a> モジュールと似た動作をしますが、これは push ではなく pull となります。コピー元が存在しない場合をエラーとするには <code>fail_on_missing</code> を <code>yes</code> にする必要があります。
管理対象サーバーからファイルを収集したい場合に利用します。
<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>dest <span class="required">*</span></td>
  <td></td>
  <td></td>
  <td class="comments">ファイルの保存先を指定します。対象ホストが <code>host.example.com</code> で <code>dest</code> が <code>/backup</code> で、<code>src</code> が <code>/etc/profile</code> の場合、<code>/backup/host.example.com/etc/profile</code> に保存されます。</td>
</tr>
<tr>
  <td>fail_on_missing</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">コピー元ファイルが存在しかなった場合を失敗として扱います。</td>
</tr>
<tr>
  <td>flat</td>
  <td></td>
  <td></td>
  <td class="comments"><code>hostname/path/to/file</code> というデフォルトの保存先の上書きを許可します。<code>dest</code> が '/' で終わる場合は basename をファイル名としてそのディレクトリに保存します。</td>
</tr>
<tr>
  <td>src</td>
  <td></td>
  <td></td>
  <td class="comments">fetch するファイルの対象ホスト上の path を指定します。ディレクトリには対応していません。再帰的なコピーは今後のリリースで対応予定です。</td>
</tr>
</table>
<span class="required">*</span> は必須<br>
<br>
例
<pre><code># Store file into /tmp/fetched/host.example.com/tmp/somefile
- fetch: src=/tmp/somefile dest=/tmp/fetched

# Specifying a path directly
- fetch: src=/tmp/somefile dest=/tmp/prefix-{{ ansible_hostname }} flat=yes

# Specifying a destination path
- fetch: src=/tmp/uniquefile dest=/tmp/special/ flat=yes

# Storing in a path relative to the playbook
- fetch: src=/tmp/uniquefile dest=special/prefix-{{ ansible_hostname }} flat=yes
</code></pre>
</p>


<h3><a name="module-lineinfile" class="anchor" href="#module-lineinfile"><span class="octicon octicon-link"></span></a>lineinfile モジュール</h3>
<p>

デフォルトの config ファイルなどを置換で変換する用途に使うと便利そうです。
<code>insertafter</code>, <code>insertbefore</code> を使うことでコメントアウトされてるかもしれないファイルをうまく扱うことができるようです。<br>
<br>
しかし、同じファイルに対して <code>backup=yes</code> な <code>lineinfile</code> タスクを複数定義してもバックアップファイルの timestamp は分の精度であるためか、最後の変更のバックアップしか残らない。

<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>backrefs</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments"><code>state=present</code> とともに使います。
セットされている場合 backreferences (ポジションと名前付きの両方) を使うことができます。このフラグはモジュールの動作を変えます。insertbefore と insertafter は無視されます。正規表現がどこにもマッチしない場合、ファイルは更新されません。複数行にマッチした場合、最後にマッチした行が置換されます。</td>
</tr>
<tr>
  <td>backup</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">タイムスタンプを含むファイル名でバックアップファイルを作成します。</td>
</tr>
<tr>
  <td>create</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments"><code>state=present</code> とともに使います。<code>yes</code> の場合、ファイルが存在しない場合に作成します。デフォルトではファイルが存在しない場合はエラーとなります。</td>
</tr>
<tr>
  <td>dest <span class="required">*</san></td>
  <td></td>
  <td></td>
  <td class="comments">編集するファイルのパス</td>
</tr>
<tr>
  <td>insertafter</td>
  <td></td>
  <td>EOF<br>*regex*</td>
  <td class="comments"><code>state=present</code> とともに使います。
<code>regexp</code> にマッチすればその行を置換するが、マッチしなかった場合にこの値にマッチした行の次の行として <code>line</code> を挿入します。
<code>EOF</code> という値は特別で、ファイル末尾に挿入されます。<code>backrefs</code> を有効にするとこのオプションは無視されます。</td>
</tr>
<tr>
  <td>insertbefore</td>
  <td></td>
  <td>EOF<br>*regex*</td>
  <td class="comments"><code>insertafter</code> とほぼ同じ動作ですが、次の行ではなく前の行として挿入されます。</td>
</tr>
<tr>
  <td>line</td>
  <td></td>
  <td></td>
  <td class="comments"><code>state=present</code> では必須。ファイルに挿入、置換する行。<code>backrefs=yes</code> の場合、正規表現の backreference が使える。<br>\1, \2 や \g&lt;name&gt;</td>
</tr>
<tr>
  <td>regexp <span class="required">*</span></td>
  <td></td>
  <td></td>
  <td class="comments">対象の行を探す正規表現を指定します。<code>state=present</code> では行を置換します。複数行にマッチする場合最後にマッチした行が置換されます。<code>state=absent</code> の場合はマッチした行が削除されます。Python の正規表現を確認してください <a href="http://docs.python.org/2/library/re.html">http://docs.python.org/2/library/re.html</a></td>
</tr>
<tr>
  <td>state</td>
  <td>present</td>
  <td>present<br>absent</td>
  <td class="comments"><code>absent</code> の場合は <code>regexp</code> にマッチする行を削除します。<code>present</code> の場合は他のオプションによってさまざまな動作をします。</td>
</tr>
<tr>
  <td>その他</td>
  <td></td>
  <td></td>
  <td class="comments">file モジュールで指定可能なものすべてが使えます</td>
</tr>
</table>

<pre><code>- lineinfile: dest=/etc/selinux/config regexp=^SELINUX= line=SELINUX=disabled

- lineinfile: dest=/etc/sudoers state=absent regexp="^%wheel"

- lineinfile: dest=/etc/hosts regexp='^127\.0\.0\.1' line='127.0.0.1 localhost' owner=root group=root mode=0644

- lineinfile: dest=/etc/httpd/conf/httpd.conf regexp="^Listen " insertafter="^#Listen " line="Listen 8080"

- lineinfile: dest=/etc/services regexp="^# port for http" insertbefore="^www.*80/tcp" line="# port for http by default"

- lineinfile: dest=/etc/sudoers state=present regexp='^%wheel' line='%wheel ALL=(ALL) NOPASSWD: ALL'

# オリジナルのドキュメントにはこう書いてあるんだけど間違ってる？
- lineinfile: dest=/opt/jboss-as/bin/standalone.conf regexp='^(.*)Xms(\d+)m(.*)$' line='\1Xms${xms}m\3' backrefs=yes

# これが正解？
- lineinfile: dest=/opt/jboss-as/bin/standalone.conf regexp='^(.*)Xms(?P&lt;xms&gt;\d+)m(.*)$' line='\1Xms\g&lt;xms&gt;m\3' backrefs=yes
</code></pre>
</p>


<h3><a name="module-user" class="anchor" href="#module-user"><span class="octicon octicon-link"></span></a>user モジュール</h3>
<p>
ユーザーアカウントの管理をするモジュールです。
<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>append</td>
  <td></td>
  <td></td>
  <td class="comments"><code>yes</code> の場合、<code>groups</code> への追加だけを行う</td>
</tr>
<tr>
  <td>comment</td>
  <td></td>
  <td></td>
  <td class="comments">アカウントのコメント (GECOS) を指定しる</td>
</tr>
<tr>
  <td>createhome</td>
  <td>yes</td>
  <td>yes<br>no</td>
  <td class="comments"><code>no</code> にしない場合はアカウント作成後にホームディレクトリを作成する</td>
</tr>
<tr>
  <td>force</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments"><code>state=absent</code> の場合、<code>userdel --force</code> として処理される</td>
</tr>
<tr>
  <td>generate_ssh_key</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">SSH key を作成するかどうか。既に存在する場合には上書きしません。</td>
</tr>
<tr>
  <td>group</td>
  <td></td>
  <td></td>
  <td class="comments">ユーザーのプライマリグループをグループ名で指定する</td>
</tr>
<tr>
  <td>groups</td>
  <td></td>
  <td></td>
  <td class="comments">カンマ区切りのグループリストにユーザーを追加する。<code>groups=</code> と、空文字列をしていするとプライマリグループ以外から削除します。</td>
</tr>
<tr>
  <td>home</td>
  <td></td>
  <td></td>
  <td class="comments">ホームディレクトリの path を指定する</td>
</tr>
<tr>
  <td>login_class</td>
  <td></td>
  <td></td>
  <td class="comments">FreeBSD, OpenBSD, NetBSD 用の login class を指定する</td>
</tr>
<tr>
  <td>name <span class="required">*</span></td>
  <td></td>
  <td></td>
  <td class="comments">操作対象のユーザー名を指定</td>
</tr>
<tr>
  <td>non_unique</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">ユニークでない uid を許可するかどうか</td>
</tr>
<tr>
  <td>password</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">ハッシュ化された文字列を指定することでパスワードを設定する</td>
</tr>
<tr>
  <td>remove</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments"><code>state=absent</code> と同時に指定することで <code>userdel --remote</code> となり、ホームディレクトリも削除される</td>
</tr>
<tr>
  <td>shell</td>
  <td></td>
  <td></td>
  <td class="comments">ログインシェルを指定する</td>
</tr>
<tr>
  <td>ssh_key_bits</td>
  <td>2048</td>
  <td></td>
  <td class="comments">作成する SSH key の bit 数を指定する</td>
</tr>
<tr>
  <td>ssh_key_comment</td>
  <td>ansible-generated</td>
  <td></td>
  <td class="comments">SSH key のコメントを指定する</td>
</tr>
<tr>
  <td>ssh_key_file</td>
  <td>$HOME/.ssh/id_rsa</td>
  <td></td>
  <td class="comments">SSH key ファイルの path を指定する</td>
</tr>
<tr>
  <td>ssh_key_passphrase</td>
  <td></td>
  <td></td>
  <td class="comments">作成する SSH key ファイルのパスフレーズ、指定しない場合はパスフレーズなしの key が作成される</td>
</tr>
<tr>
  <td>ssh_key_type</td>
  <td>rsa</td>
  <td></td>
  <td class="comments">SSH key の暗号アルゴリズムを指定する、利用可能なものはそのホストの環境に依存する</td>
</tr>
<tr>
  <td>state</td>
  <td>present</td>
  <td>present<br>absent</td>
  <td class="comments"><code>absent</code> でユーザーを削除する</td>
</tr>
<tr>
  <td>system</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">システムアカウントとして作成する。既存のアカウントの設定を変更することはできない</td>
</tr>
<tr>
  <td>uid</td>
  <td></td>
  <td></td>
  <td class="comments">uid を指定する</td>
</tr>
<tr>
  <td>update_password</td>
  <td>always</td>
  <td>always<br>on_create</td>
  <td class="comments">パスワードをいつでも変更可能 (<code>always</code>) にするか、作成時 (<code>on_create</code>) のみにするか</td>
</tr>
</table>
<span class="required">*</span> は必須<br>
<br>

<code>useradd</code>, <code>userdel</code>, <code>usermod</code> コマンドが必要。

<pre><code># 'johnd' ユーザーを指定の uid で、プライマリグループ admin で作成する
- user: name=johnd comment="John Doe" uid=1040 group=admin

# 'johnd' ユーザーを削除する、ホームディレクトリも削除する
- user: name=johnd state=absent remove=yes

# jsmith の 2048-bit SSH key を作成する
- user: name=jsmith generate_ssh_key=yes ssh_key_bits=2048
</code></pre>

パスワードなどは prompt を表示させて入力を変数にいれることでセキュリティを保つことができる。ハッシュ化には <a href="http://pythonhosted.org/passlib/">Passlib</a> モジュールが必要となる。CentOS 6 では <code>yum -y install python-passlib</code> で EPEL リポジトリがインストールできる。

</p>


<h3><a name="module-yum" class="anchor" href="#module-yum"><span class="octicon octicon-link"></span></a>yum モジュール</h3>
<p>
yum を使ってパッケージのインストール、更新、削除、リストを行うモジュールです。

<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>conf_file</td>
  <td></td>
  <td></td>
  <td class="comments">対象ホストで /etc/yum.conf 以外を使う場合に指定</td>
</tr>
<tr>
  <td>disable_gpg_check</td>
  <td>no</td>
  <td>yes<br>no</td>
  <td class="comments">パッケージのシグネチャチェックを無効にする</td>
</tr>
<tr>
  <td>disablerepo</td>
  <td></td>
  <td></td>
  <td class="comments">実行時に無効にしたいリポジトリを指定する。カンマ区切りで複数指定可能</td>
</tr>
<tr>
  <td>enablerepo</td>
  <td></td>
  <td></td>
  <td class="comments">デフォルトで無効にしているが実行時に有効にしたいリポジトリを指定する。カンマ区切りで複数指定可能</td>
</tr>
<tr>
  <td>list</td>
  <td></td>
  <td></td>
  <td class="comments">ansible-playbook ではなく ansible コマンド用。冪等でない。例を見よと書いてあるが例に載ってない...</td>
</tr>
<tr>
  <td>name <span class="required">*</span></td>
  <td></td>
  <td></td>
  <td class="comments">パッケージ名 <code>state=latest</code> で <code>name=*</code> の場合は <code>yum -y update</code> を意味する </td>
</tr>
<tr>
  <td>state</td>
  <td>present</td>
  <td>present<br>latest<br>absent</td>
  <td class="comments"><code>present</code> はインストールされていること、最新は求めない。<code>lastest</code> は最新に更新する。<code>absent</code> はインストールされていない状態にする</td>
</tr>
</table>
<span class="required">*</span> は必須<br>
<br>
例
<pre><code>- yum: name=httpd state=latest
- yum: name=httpd state=absent
- yum: name=httpd enablerepo=testing state=installed
# yum -y update
- yum: name=* state=latest
</code></pre>
</p>


<h3><a name="module-command" class="anchor" href="#module-command"><span class="octicon octicon-link"></span></a>command モジュール</h3>
<p>
<code>command</code> モジュールはスペース区切りの引数とともにコマンドを対象のサーバー上で実行します。ただし、このコマンドは shell に渡されるわけではないため "&lt;", "&gt;", "|", "&amp;" や $HOME などの変数を使うことはできません。また、path は絶対パスで指定する必要があります。

<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>chdir</td>
  <td></td>
  <td></td>
  <td class="comments">コマンドを特定のディレクトリで実行する必要がある場合に指定します</td>
</tr>
<tr>
  <td>creates</td>
  <td></td>
  <td></td>
  <td class="comments">このコマンドの実行結果として、作成されるファイルの path を指定します。ファイルが存在する場合はコマンドを実行しません</td>
</tr>
<tr>
  <td>executable</td>
  <td></td>
  <td></td>
  <td class="comments">subprocess.Popen の executable オプション</td>
</tr>
<tr>
  <td>free_form <span class="required">*</span></td>
  <td></td>
  <td></td>
  <td class="comments">実行するコマンドをスペース区切りの引数付きで指定します</td>
</tr>
<tr>
  <td>removes</td>
  <td></td>
  <td></td>
  <td class="comments">このコマンドの実行結果として、削除されるファイルの path を指定します。ファイルが存在しない場合はコマンドを実行しません</td>
</tr>
</table>
<span class="required">*</span> は必須<br>
<br>
例
<pre><code># Example from Ansible Playbooks
- command: /sbin/shutdown -t now

# 指定したファイルが存在しなかった場合にのみコマンドを実行する
- command: /usr/bin/make_database.sh arg1 arg2 creates=/path/to/database
</code></pre>

<strong>Notes</strong><br>
<code>&lt;</code>, <code>&gt;</code>, <code>|</code> を使うために shell に渡したい場合は <code>shell</code> モジュールを使います。<br><br><code>creates</code>, <code>removes</code>, <code>chdir</code> はコマンドの後に指定します。(コマンドには名前がつかないため)

</p>


<h3><a name="module-pause" class="anchor" href="#module-pause"><span class="octicon octicon-link"></span></a>pause モジュール</h3>
<p>
ポーズモジュールは task の実行後一定時間待つ必要がある場合などに使います。サーバー起動時の初期化に時間がかかるため、起動完了まで待つ場合など。
<code>minutes</code>, <code>seconds</code> で時間を指定した場合、指定時間経過で自動的に次の task へ進みます。そうでない場合は入力をずっと待ちます。時間を指定した場合もしなかった場合も待っている間に Ctrl-C を入力すると即座に次に進むか、中断してそれ以降の task の実行も行わないかの選択プロンプトが表示されます。

<pre><code>TASK: [pause test] ************************************************************ 
[servername]
Press enter to continue: ^C
Action? (a)bort/(c)ontinue:
</code></pre>

<table class="module-option">
<tr>
  <th>parameter</th>
  <th>default</th>
  <th>choices</th>
  <th>comments</th>
</tr>
<tr>
  <td>minutes</td>
  <td></td>
  <td></td>
  <td class="comments">指定の分待ちます。経過後自動で先に進みます</td>
</tr>
<tr>
  <td>prompt</td>
  <td></td>
  <td></td>
  <td class="comments">指定の文字列を表示して待ちます</td>
</tr>
<tr>
  <td>seconds</td>
  <td></td>
  <td></td>
  <td class="comments">指定の秒待ちます。経過後自動で先に進みます</td>
</tr>
</table>
<br>
例
<pre><code># アプリケーションのキャッシュ生成のため5分待つ
- pause: minutes=5

# アプリケーションが正しく更新されたことを確認するまで待つ。(何かを入力するまで待つ)
- pause:

# 更新後の確認事項のリマインダーとして役に立つ
- pause: prompt="Make sure org.foo.FooOverload exception is not present"
</code></pre>
</p>



<h3><a name="register-variables" class="anchor" href="#register-variables"><span class="octicon octicon-link"></span></a>結果を変数に保存して利用する</h3>
<p>
<code>register</code> を使って task の結果、出力を変数に登録し、後の task でその値を利用することができます。
<pre><code>- name: test play
  hosts: all
  tasks:
      - shell: cat /etc/motd
        register: motd_contents
      - shell: echo "motd contains the word hi"
        when: motd_contents.stdout.find('hi') != -1
</code></pre>
<code>cat /etc/motd</code> の結果が motd_contents に登録されます。上の例では /etc/motd に "hi" が含まれなかった場合にのみ2つ目の task が実行されます。<br>
<br>
task の出力をリストにして <code>with_items</code> で扱うことも可能です。行を単位にするなら stdout_lines が使えます。 stdout.split() で任意のデリミタでリストに分割することもできます。
<pre><code>- name: registered variable usage as a with_items list
  hosts: all
  tasks:
      - name: retrieve the list of home directories
        command: ls /home
        register: home_dirs
      - name: add home dirs to the backup spooler
        file: path=/mnt/bkspool/{{ item }} src=/home/{{ item }} state=link
        with_items: home_dirs.stdout_lines
        # with_items: home_dirs.stdout.split()
</code></pre>

<code>register</code> で登録されるデータは <code>debug</code> モジュールを使うことで確認できます。<code>debug</code> モジュールの出力を有効にするには <code>-v</code> オプションをつけて実行する必要があります。

<pre><code>      - debug: msg="{{motd_contents}}"</code></pre>

これを実行すると次のように表示されます。

<pre><code>TASK: [debug msg="{{motd_contents}}"] ***************************************** 
<span class="console-green">ok: [192.168.33.12] =&gt; {"msg": "{u'changed': True, u'end': u'2013-08-18 15:12:18.808685', u'stdout': u'Welcome to your Vagrant-built virtual machine.', u'cmd': u'cat /etc/motd ', u'start': u'2013-08-18 15:12:18.803476', u'delta': u'0:00:00.005209', u'stderr': u'', u'rc': 0, 'invocation': {'module_name': 'shell', 'module_args': 'cat /etc/motd'}, 'stdout_lines': [u'Welcome to your Vagrant-built virtual machine.']}"}</span></code></pre>

長いので整形してみます。

<pre><code>u'changed': True,
u'end': u'2013-08-18 15:12:18.808685',
u'stdout': u'Welcome to your Vagrant-built virtual machine.',
u'cmd': u'cat /etc/motd ',
u'start': u'2013-08-18 15:12:18.803476',
u'delta': u'0:00:00.005209',
u'stderr': u'',
u'rc': 0,
'invocation': {
  'module_name': 'shell',
  'module_args': 'cat /etc/motd'
},
'stdout_lines': [u'Welcome to your Vagrant-built virtual machine.']
</code></pre>

skip した場合

<pre><code>
u'skipped': True,
u'stdout': u'skipped, since /etc/motd exists',
u'cmd': u'cat /etc/motd ',
u'rc': 0,
u'stderr': False,
u'changed': False,
'invocation': {
  'module_name': 'shell',
  'module_args': 'cat /etc/motd creates=/etc/motd'
},
'stdout_lines': [u'skipped, since /etc/motd exists']
</code></pre>

もっと手軽に確認したい場合は <code>debug</code> モジュールなしに <code>-v</code> をつけて実行することでもだいたい確認することができます。

<pre><code>TASK: [shell cat /etc/motd] *************************************************** 
<span class="console-yellow">changed: [192.168.33.12] =&gt; {"changed": true, "cmd": "cat /etc/motd ", "delta": "0:00:00.005462", "end": "2013-08-18 13:27:43.277139", "rc": 0, "start": "2013-08-18 13:27:43.271677", "stderr": "", "stdout": "Welcome to your Vagrant-built virtual machine."}</span></code></pre>
これも長いので整形してみましょう。
<pre><code>{
  "changed": true,
  "cmd": "cat /etc/motd ",
  "delta": "0:00:00.005462",
  "end": "2013-08-18 13:27:43.277139",
  "rc": 0,
  "start": "2013-08-18 13:27:43.271677",
  "stderr": "",
  "stdout": "Welcome to your Vagrant-built virtual machine."
}
</code></pre>
skip した場合は次のような文字列が stdout に入っていました。
<pre><code>skipped, since /etc/motd exists</code></pre>
そして、実は <code>debug</code> モジュールを使えば中身が見れるのでした。
</p>



<h3><a name="gathering-facts" class="anchor" href="#gathering-facts"><span class="octicon octicon-link"></span></a>サーバーの情報を利用する (GATHERING FACTS)</h3>
<p>
playbook を実行するとまずサーバの情報を収集します。
実行時に <code>GATHERING FACTS</code> を表示されている部分です。次のような情報が収集され、これを task の中で利用することができます。
<pre style="height: 300px;"><code>$ <span class="console-input">ansible -m setup -i hosts 192.168.33.12</span>
192.168.33.12 | success &gt;&gt; {
    "ansible_facts": {
        "ansible_all_ipv4_addresses": [
            "10.0.2.15", 
            "192.168.33.12"
        ], 
        "ansible_all_ipv6_addresses": [
            "fe80::a00:27ff:fec9:399e", 
            "fe80::a00:27ff:fed5:dab6"
        ], 
        "ansible_architecture": "x86_64", 
        "ansible_bios_date": "12/01/2006", 
        "ansible_bios_version": "VirtualBox", 
        "ansible_cmdline": {
            "KEYBOARDTYPE": "pc", 
            "KEYTABLE": "us", 
            "LANG": "en_US.UTF-8", 
            "SYSFONT": "latarcyrheb-sun16", 
            "quiet": true, 
            "rd_LVM_LV": "VolGroup/lv_root", 
            "rd_NO_DM": true, 
            "rd_NO_LUKS": true, 
            "rd_NO_MD": true, 
            "rhgb": true, 
            "ro": true, 
            "root": "/dev/mapper/VolGroup-lv_root"
        }, 
        "ansible_date_time": {
            "date": "2013-08-08", 
            "day": "08", 
            "epoch": "1375968652", 
            "hour": "13", 
            "iso8601": "2013-08-08T13:30:52Z", 
            "iso8601_micro": "2013-08-08T13:30:52.873665Z", 
            "minute": "30", 
            "month": "08", 
            "second": "52", 
            "time": "13:30:52", 
            "tz": "UTC", 
            "year": "2013"
        }, 
        "ansible_default_ipv4": {
            "address": "10.0.2.15", 
            "alias": "eth0", 
            "gateway": "10.0.2.2", 
            "interface": "eth0", 
            "macaddress": "08:00:27:c9:39:9e", 
            "mtu": 1500, 
            "netmask": "255.255.255.0", 
            "network": "10.0.2.0", 
            "type": "ether"
        }, 
        "ansible_default_ipv6": {}, 
        "ansible_devices": {
            "sda": {
                "holders": [], 
                "host": "SATA controller: Intel Corporation 82801HM/HEM (ICH8M/ICH8M-E) SATA Controller [AHCI mode] (rev 02)", 
                "model": "VBOX HARDDISK", 
                "partitions": {
                    "sda1": {
                        "sectors": "1024000", 
                        "sectorsize": 512, 
                        "size": "500.00 MB", 
                        "start": "2048"
                    }, 
                    "sda2": {
                        "sectors": "1047549952", 
                        "sectorsize": 512, 
                        "size": "499.51 GB", 
                        "start": "1026048"
                    }
                }, 
                "removable": "0", 
                "rotational": "1", 
                "scheduler_mode": "cfq", 
                "sectors": "1048576000", 
                "sectorsize": "512", 
                "size": "500.00 GB", 
                "support_discard": "0", 
                "vendor": "ATA"
            }, 
            "sr0": {
                "holders": [], 
                "host": "IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)", 
                "model": "CD-ROM", 
                "partitions": {}, 
                "removable": "1", 
                "rotational": "1", 
                "scheduler_mode": "cfq", 
                "sectors": "2097151", 
                "sectorsize": "512", 
                "size": "1024.00 MB", 
                "support_discard": "0", 
                "vendor": "VBOX"
            }, 
            "sr1": {
                "holders": [], 
                "host": "IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)", 
                "model": "CD-ROM", 
                "partitions": {}, 
                "removable": "1", 
                "rotational": "1", 
                "scheduler_mode": "cfq", 
                "sectors": "2097151", 
                "sectorsize": "512", 
                "size": "1024.00 MB", 
                "support_discard": "0", 
                "vendor": "VBOX"
            }
        }, 
        "ansible_distribution": "CentOS", 
        "ansible_distribution_release": "Final", 
        "ansible_distribution_version": "6.4", 
        "ansible_domain": "localdomain", 
        "ansible_eth0": {
            "active": true, 
            "device": "eth0", 
            "ipv4": {
                "address": "10.0.2.15", 
                "netmask": "255.255.255.0", 
                "network": "10.0.2.0"
            }, 
            "ipv6": [
                {
                    "address": "fe80::a00:27ff:fec9:399e", 
                    "prefix": "64", 
                    "scope": "link"
                }
            ], 
            "macaddress": "08:00:27:c9:39:9e", 
            "module": "e1000", 
            "mtu": 1500, 
            "type": "ether"
        }, 
        "ansible_eth1": {
            "active": true, 
            "device": "eth1", 
            "ipv4": {
                "address": "192.168.33.12", 
                "netmask": "255.255.255.0", 
                "network": "192.168.33.0"
            }, 
            "ipv6": [
                {
                    "address": "fe80::a00:27ff:fed5:dab6", 
                    "prefix": "64", 
                    "scope": "link"
                }
            ], 
            "macaddress": "08:00:27:d5:da:b6", 
            "module": "e1000", 
            "mtu": 1500, 
            "type": "ether"
        }, 
        "ansible_form_factor": "Other", 
        "ansible_fqdn": "localhost.localdomain", 
        "ansible_hostname": "localhost", 
        "ansible_interfaces": [
            "lo", 
            "eth1", 
            "eth0"
        ], 
        "ansible_kernel": "2.6.32-358.el6.x86_64", 
        "ansible_lo": {
            "active": true, 
            "device": "lo", 
            "ipv4": {
                "address": "127.0.0.1", 
                "netmask": "255.0.0.0", 
                "network": "127.0.0.0"
            }, 
            "ipv6": [
                {
                    "address": "::1", 
                    "prefix": "128", 
                    "scope": "host"
                }
            ], 
            "mtu": 16436, 
            "type": "loopback"
        }, 
        "ansible_machine": "x86_64", 
        "ansible_memfree_mb": 323, 
        "ansible_memtotal_mb": 458, 
        "ansible_mounts": [
            {
                "device": "/dev/mapper/VolGroup-lv_root", 
                "fstype": "ext4", 
                "mount": "/", 
                "options": "rw", 
                "size_available": 497491697664, 
                "size_total": 525282689024
            }, 
            {
                "device": "/dev/sda1", 
                "fstype": "ext4", 
                "mount": "/boot", 
                "options": "rw", 
                "size_available": 448802816, 
                "size_total": 507744256
            }, 
            {
                "device": "/vagrant", 
                "fstype": "vboxsf", 
                "mount": "/vagrant", 
                "options": "uid=501,gid=501,rw", 
                "size_available": 72607436800, 
                "size_total": 117461032960
            }
        ], 
        "ansible_os_family": "RedHat", 
        "ansible_pkg_mgr": "yum", 
        "ansible_processor": [
            "Intel(R) Core(TM) i3-3217U CPU @ 1.80GHz"
        ], 
        "ansible_processor_cores": "NA", 
        "ansible_processor_count": 1, 
        "ansible_product_name": "VirtualBox", 
        "ansible_product_serial": "NA", 
        "ansible_product_uuid": "NA", 
        "ansible_product_version": "1.2", 
        "ansible_python_version": "2.6.6", 
        "ansible_selinux": false, 
        "ansible_ssh_host_key_dsa_public": "...", 
        "ansible_ssh_host_key_rsa_public": "...", 
        "ansible_swapfree_mb": 2559, 
        "ansible_swaptotal_mb": 2559, 
        "ansible_system": "Linux", 
        "ansible_system_vendor": "innotek GmbH", 
        "ansible_user_id": "vagrant", 
        "ansible_userspace_architecture": "x86_64", 
        "ansible_userspace_bits": "64", 
        "ansible_virtualization_role": "guest", 
        "ansible_virtualization_type": "virtualbox", 
        "facter_architecture": "x86_64", 
        "facter_augeasversion": "0.9.0", 
        "facter_blockdevice_sda_model": "VBOX HARDDISK", 
        "facter_blockdevice_sda_size": 536870912000, 
        "facter_blockdevice_sda_vendor": "ATA", 
        "facter_blockdevice_sr0_model": "CD-ROM", 
        "facter_blockdevice_sr0_size": 1073741312, 
        "facter_blockdevice_sr0_vendor": "VBOX", 
        "facter_blockdevice_sr1_model": "CD-ROM", 
        "facter_blockdevice_sr1_size": 1073741312, 
        "facter_blockdevice_sr1_vendor": "VBOX", 
        "facter_blockdevices": "sda,sr0,sr1", 
        "facter_facterversion": "1.7.0", 
        "facter_filesystems": "ext4,iso9660", 
        "facter_hardwareisa": "x86_64", 
        "facter_hardwaremodel": "x86_64", 
        "facter_hostname": "localhost", 
        "facter_id": "vagrant", 
        "facter_interfaces": "eth0,eth1,lo", 
        "facter_ipaddress": "10.0.2.15", 
        "facter_ipaddress_eth0": "10.0.2.15", 
        "facter_ipaddress_eth1": "192.168.33.12", 
        "facter_ipaddress_lo": "127.0.0.1", 
        "facter_is_virtual": "true", 
        "facter_kernel": "Linux", 
        "facter_kernelmajversion": "2.6", 
        "facter_kernelrelease": "2.6.32-358.el6.x86_64", 
        "facter_kernelversion": "2.6.32", 
        "facter_macaddress": "08:00:27:C9:39:9E", 
        "facter_macaddress_eth0": "08:00:27:C9:39:9E", 
        "facter_macaddress_eth1": "08:00:27:D5:DA:B6", 
        "facter_memoryfree": "366.08 MB", 
        "facter_memoryfree_mb": "366.08", 
        "facter_memorysize": "458.64 MB", 
        "facter_memorysize_mb": "458.64", 
        "facter_memorytotal": "458.64 MB", 
        "facter_mtu_eth0": "1500", 
        "facter_mtu_eth1": "1500", 
        "facter_mtu_lo": "16436", 
        "facter_netmask": "255.255.255.0", 
        "facter_netmask_eth0": "255.255.255.0", 
        "facter_netmask_eth1": "255.255.255.0", 
        "facter_netmask_lo": "255.0.0.0", 
        "facter_network_eth0": "10.0.2.0", 
        "facter_network_eth1": "192.168.33.0", 
        "facter_network_lo": "127.0.0.0", 
        "facter_operatingsystem": "CentOS", 
        "facter_operatingsystemmajrelease": "6", 
        "facter_operatingsystemrelease": "6.4", 
        "facter_osfamily": "RedHat", 
        "facter_path": "/usr/local/bin:/bin:/usr/bin", 
        "facter_physicalprocessorcount": 1, 
        "facter_processor0": "Intel(R) Core(TM) i3-3217U CPU @ 1.80GHz", 
        "facter_processorcount": "1", 
        "facter_ps": "ps -ef", 
        "facter_puppetversion": "3.1.1", 
        "facter_rubysitedir": "/usr/lib/ruby/site_ruby/1.8", 
        "facter_rubyversion": "1.8.7", 
        "facter_selinux": "false", 
        "facter_sshdsakey": "...", 
        "facter_sshfp_dsa": "SSHFP 2 1 ...\nSSHFP 2 2 ...", 
        "facter_sshfp_rsa": "SSHFP 1 1 ...\nSSHFP 1 2 ...", 
        "facter_sshrsakey": "...", 
        "facter_swapfree": "2.50 GB", 
        "facter_swapfree_mb": "2559.99", 
        "facter_swapsize": "2.50 GB", 
        "facter_swapsize_mb": "2559.99", 
        "facter_timezone": "UTC", 
        "facter_uniqueid": "007f0100", 
        "facter_uptime": "1:09 hours", 
        "facter_uptime_days": 0, 
        "facter_uptime_hours": 1, 
        "facter_uptime_seconds": 4195, 
        "facter_virtual": "virtualbox"
    }, 
    "changed": false
}
</pre></code>
templates で IP address を埋める場合には <code>{{ansible_eth0.ipv4.address}}</code> と書けます。<code>{{ansible_eth0["ipv4"]["address"]}}</code> でも可。<br>
<code>{{ansible_processor_count * 5}}</code> として計算結果を利用することもできます。次に説明する<a href="#conditional-execution">条件付き実行</a>の条件としても使えます。<br>
<br>
この収集処理にはそこそこ時間がかかるため、このデータを利用しない場合は playbook で <code>gather_facts: no</code> と指定することで省略することが可能です。
</p>



<h3><a name="conditional-execution" class="anchor" href="#conditional-execution"><span class="octicon octicon-link"></span></a>条件付き実行</h3>
<p>
task に when で条件を指定し、それを満たす場合にのみ実行させることができます。<br>
次の例では Debian でのみコマンドを実行します。この変数 <codoe>ansible_os_family</code> は <a href="#gathering-facts">GATHERING FACTS</a> で得られるものです。
<pre><code>tasks:
  - name: "shutdown Debian flavored systems"
    command: /sbin/shutdown -t now
    when: ansible_os_family == "Debian"
</code></pre>

<pre><code>tasks:
  - shell: echo "only on Red Hat 6, derivatives, and later"
    when: ansible_os_family == "RedHat" and ansible_lsb.major_release|int &gt;= 6
</pre></code>
<br>
<code>ansible-playbook</code> <code>-e nmae=value</code> で指定した変数によって動作を変えることができます。
<pre><code># is_hogehoge 変数に何か指定してある場合
  - command: hogehoge
    when: is_hogehoge is defined

# branch を指定して deploy
  - command: deploy-command {{branch}}
</code></pre>
<br>

また、ある <a href="#register-variables">task の結果を変数に入れて</a>おき、その値を使って条件を指定することができます。

<pre><code>tasks:
  - command: /bin/false
    register: result
    ignore_errors: True
  - command: /bin/something
    when: result|failed
  - command: /bin/something_else
    when: result|success
</code></pre>
1番目の task は /bin/false なのでかならず失敗しますが、<code>ignore_errors</code> によってエラーでも続行されます。<code>register</code> で <code>result</code> という変数に task の結果が保存されます(<a href="#register-variables">結果を変数に保存して利用する</a> を参照)。以降の task で <code>when</code> を使ってその結果を条件として利用することができます。2番目の task は1番目が失敗した場合にのみ実行されます。3番目は1番目の task が成功した場合にのみ実行されます。
<code>register: 任意の名前</code> で結果を保存します。<br>
(<a href="http://www.ansibleworks.com/docs/playbooks2.html#conditional-execution">Conditional Execution</a>)
<br>
<br>
次の例は <code>/some/directory</code> が作成された場合にのみ、次の <code>commmand a</code> が実行されます。<code>/some/directory</code> が既に存在していた場合は <code>changed</code> とならないので <code>command a</code> は実行されません。
<pre><code>  - file: state=directory path=/some/directory
    register: create_dir

  - command: command a
    when: create_dir.changed
</code></pre>
</p>



<h3><a name="backup-file" class="anchor" href="#backup-file"><span class="octicon octicon-link"></span></a>Backup File</h3>
<p>
<a href="#module-copy"><code>copy</code></a>, <a href="#module-lineinfile"><code>lineinfile</code></a> などに <code>backup</code> オプションがある。これは更新対象のファイル(path)に日時(%Y-%m-%d@%H:%M~)サフィックスをつけてバックアップとして保存します。変更の必要がない場合はバックアップファイルも作成されません。<br>
<br>
当該部分のコードは <code>ansible/module_common.py</code> にある
<pre><code>    def backup_local(self, fn):
        '''make a date-marked backup of the specified file, return True or False on success or failure'''
        # backups named basename-YYYY-MM-DD@HH:MM~
        ext = time.strftime("%Y-%m-%d@%H:%M~", time.localtime(time.time()))
        backupdest = '%s.%s' % (fn, ext)

        try:
            shutil.copy2(fn, backupdest)
        except shutil.Error, e:
            self.fail_json(msg='Could not make backup of %s to %s: %s' % (fn, backupdest, e))
        return backupdest
</code></pre>

分の精度の日時だけでのバックアップファイル名を生成するため、一度の playbook 適用内で同一ファイルを複数回更新する処理を行なっても最後の変更分しか残らないので注意が必要。たまたまtaskの間に分が変われば複数ファイルが残ります。
ファイルのコピーには <code>shutil.copy2</code> が使われているのでメタデータもすべてコピーされます。
</p>


<h3><a name="ignore_errors" class="anchor" href="#ignore_errors"><span class="octicon octicon-link"></span></a>エラーを無視する</h3>
<p>
通常、task でエラーが発生するとそのホストに対してはそれ以降の処理を行いませんが、エラーになっても処理を続けたい場合にはその task に
<pre><code>ignore_errors: yes</code></pre>
を設定することで実現できます。
</p>



<h3><a name="delegation" class="anchor" href="#delegation"><span class="octicon octicon-link"></span></a>委譲 (task を別のホストで実行する)</h3>
<p>
例えば deploy の前にロードバランサーから外し、終わったらまた戻すという処理を行う場合 <code>delegate_to</code> を使ってその task をロードバランサーで実行させることができます。
<pre><code>- hosts: webservers
  serial: 5
  tasks:
  - name: take out of load balancer pool
    command: /usr/bin/take_out_of_pool {{ inventory_hostname }}
    delegate_to: 127.0.0.1
  - name: actual steps would go here
    yum: name=acme-web-stack state=latest
  - name: add back to load balancer pool
    command: /usr/bin/add_back_to_pool {{ inventory_hostname }}
    delegate_to: 127.0.0.1
</code></pre>
この例ではロードバランサーの処理を 127.0.0.1 で実行します。これは Ansible の実行ホストです。この場合 <code>local_action</code> を使って次のように書くこともできます。
<pre><code># ...
  tasks:
  - name: take out of load balancer pool
    local_action: command /usr/bin/take_out_of_pool {{ inventory_hostname }}
# ...
  - name: add back to load balancer pool
    local_action: command /usr/bin/add_back_to_pool {{ inventory_hostname }}
</code></pre>
<code>local_action</code> を使うことで file モジュールではできないディレクトリごとファイルをコピーする処理を次のように書くこともできます。
<pre><code># ...
  tasks:
  - name: recursively copy files from management server to target
    local_action: command rsync -a /path/to/files {{ inventory_hostname }}:/path/to/target/
</code></pre>
</p>


<h3><a name="advanced-playbook" class="anchor" href="#advanced-playbook"><span class="octicon octicon-link"></span></a>Advanced Playbook</h3>
<p>
これ必見!!
<a href="http://www.ansibleworks.com/docs/playbooks2.html/">高度な Playbook の書き方</a>
</p>

<!--
<h3><a name="inventory-file" class="anchor" href="#inventory-file"><span class="octicon octicon-link"></span></a>インベントリファイル</h3>
<p>
</p>
-->

        </section>

        <footer>
          Ansible Tutorial is maintained by <a href="https://github.com/yteraoka">yteraoka</a>
        </footer>

        
      </div>
    </div>
  </body>
</html>
